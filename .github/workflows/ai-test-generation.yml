name: AI-Powered Test Generation with JaCoCo

on:
  workflow_dispatch:
    inputs:
      max_classes:
        description: 'Maximum number of classes to generate tests for'
        required: true
        default: '5'
      min_coverage:
        description: 'Minimum coverage percentage threshold'
        required: true
        default: '80'
  schedule:
    # Run weekly on Monday at 1 AM
    - cron: '0 1 * * 1'

jobs:
  generate-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for test analysis

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'zulu'
          cache: maven

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Create requirements.txt
        run: |
          echo "requests>=2.31.0" > requirements.txt

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Create directories for scripts
        run: |
          mkdir -p .github/scripts

      - name: Create SambaNova API Helper
        run: |
          cat > .github/scripts/sambanova_api_helper.py << 'EOF'
          import os
          import json
          import requests
          from typing import Dict, List, Any
          
          
          class SambaNovaCoder:
              """Helper class for interacting with SambaNova's Qwen2.5-Coder API."""
              
              def __init__(self, api_key=None, model="Qwen2.5-Coder-32B-Instruct"):
                  """Initialize with API key and model name."""
                  self.api_key = api_key or os.environ.get("SAMBANOVA_API_KEY")
                  if not self.api_key:
                      raise ValueError("SAMBANOVA_API_KEY environment variable not set")
                  
                  self.base_url = "https://api.sambanova.ai/v1"
                  self.model = model
                  self.headers = {
                      "Authorization": f"Bearer {self.api_key}",
                      "Content-Type": "application/json"
                  }
              
              def generate_test(self, class_source: str, class_name: str, method_name: str) -> str:
                  """Generate a test for a specific method in a class."""
                  prompt = self._create_test_generation_prompt(class_source, class_name, method_name)
                  response = self._call_api(prompt)
                  return self._extract_code_from_response(response)
              
              def generate_complete_test_class(self, class_source: str, class_name: str, methods: List[Dict[str, Any]]) -> str:
                  """Generate a complete test class for a Java class."""
                  prompt = self._create_test_class_prompt(class_source, class_name, methods)
                  response = self._call_api(prompt)
                  return self._extract_code_from_response(response)
              
              def _call_api(self, prompt: str) -> str:
                  """Make a call to the SambaNova API."""
                  data = {
                      "stream": False,
                      "model": self.model,
                      "messages": [
                          {
                              "role": "system",
                              "content": "You are a Java testing expert specializing in creating effective JUnit 5 tests for Dropwizard and Jakarta XML Web Services applications. Follow testing best practices, use Mockito for mocking, and ensure thorough test coverage."
                          },
                          {
                              "role": "user",
                              "content": prompt
                          }
                      ],
                      "temperature": 0.1,
                      "top_p": 0.1
                  }
                  
                  try:
                      response = requests.post(
                          f"{self.base_url}/chat/completions", 
                          headers=self.headers,
                          json=data
                      )
                      response.raise_for_status()
                      result = response.json()
                      if "choices" in result and result["choices"]:
                          return result["choices"][0]["message"]["content"]
                      else:
                          raise ValueError(f"Unexpected response format: {result}")
                  except requests.RequestException as e:
                      print(f"API request failed: {e}")
                      if hasattr(e, 'response') and e.response:
                          print(f"Response: {e.response.text}")
                      raise
              
              def _create_test_generation_prompt(self, class_source: str, class_name: str, method_name: str) -> str:
                  """Create a prompt for generating a test for a specific method."""
                  return f"""
          I need you to create a JUnit 5 test for the following method in {class_name}:
          
          ```java
          {class_source}
          ```
          
          Focus on testing the method: {method_name}
          
          Generate a comprehensive test that:
          1. Tests the happy path
          2. Tests edge cases and exceptions
          3. Uses Mockito to mock dependencies
          4. Follows best practices for Java testing
          5. Will increase code coverage
          
          Return ONLY the test method code in a Java code block, nothing else.
          """
              
              def _create_test_class_prompt(self, class_source: str, class_name: str, methods: List[Dict[str, Any]]) -> str:
                  """Create a prompt for generating a complete test class."""
                  methods_str = "\n".join([f"- {m['method']} (current coverage: {m['coverage_percentage']:.1f}%)" for m in methods])
                  
                  return f"""
          I need you to create a complete JUnit 5 test class for testing {class_name}. Here's the source code:
          
          ```java
          {class_source}
          ```
          
          Focus on testing these methods with low coverage:
          {methods_str}
          
          Requirements:
          1. Create a properly structured test class named {class_name.split('.')[-1]}Test
          2. Include proper imports for JUnit 5, Mockito, and AssertJ
          3. Include @BeforeEach method to set up test fixtures and mocks
          4. Create separate test methods for each scenario
          5. Use descriptive method names (should_X_when_Y pattern)
          6. Mock all external dependencies
          7. Test both happy paths and edge cases/exceptions
          8. Ensure thorough test coverage
          
          Return the COMPLETE test class as a single Java code block.
          """
              
              def _extract_code_from_response(self, response: str) -> str:
                  """Extract code blocks from the API response."""
                  import re
                  
                  # Try to find Java code blocks
                  java_blocks = re.findall(r'```java\n([\s\S]*?)\n```', response)
                  if java_blocks:
                      return "\n".join(java_blocks)
                  
                  # If no code blocks with "java" tag, try without language specification
                  code_blocks = re.findall(r'```\n([\s\S]*?)\n```', response)
                  if code_blocks:
                      return "\n".join(code_blocks)
                  
                  # If still no code blocks, return the whole response
                  return response
          EOF

      - name: Create JaCoCo Test Generator Script
        run: |
          cat > .github/scripts/jacoco_test_generator.py << 'EOF'
          #!/usr/bin/env python3
          """
          Improved Test Generator using JaCoCo XML Report
          
          This script parses the JaCoCo XML report directly to find coverage gaps
          and uses SambaNova to generate tests for the uncovered code.
          """
          
          import os
          import sys
          import argparse
          import xml.etree.ElementTree as ET
          import re
          import json
          from typing import List, Dict, Any
          import subprocess
          from pathlib import Path
          
          # Import the SambaNova helper
          from sambanova_api_helper import SambaNovaCoder
          
          def parse_args():
              """Parse command line arguments."""
              parser = argparse.ArgumentParser(description='Generate tests to improve code coverage')
              parser.add_argument('--max-classes', type=int, default=5,
                                  help='Maximum number of classes to generate tests for')
              parser.add_argument('--jacoco-report', type=str, default='target/site/jacoco/jacoco.xml',
                                  help='Path to the JaCoCo XML report')
              parser.add_argument('--src-dir', type=str, default='src/main/java',
                                  help='Source directory for Java classes')
              parser.add_argument('--test-dir', type=str, default='src/test/java',
                                  help='Directory to write generated tests to')
              parser.add_argument('--min-coverage', type=float, default=80.0,
                                  help='Minimum coverage percentage threshold (default: 80.0)')
              return parser.parse_args()
          
          def find_coverage_gaps(jacoco_path: str, min_coverage: float = 80.0) -> List[Dict[str, Any]]:
              """Find methods with low coverage from JaCoCo report."""
              print(f"Analyzing coverage report at {jacoco_path}")
              
              try:
                  if not os.path.exists(jacoco_path):
                      print(f"JaCoCo report not found at {jacoco_path}")
                      # Try to find it
                      report_files = list(Path('.').glob('**/jacoco.xml'))
                      if report_files:
                          jacoco_path = str(report_files[0])
                          print(f"Found JaCoCo report at: {jacoco_path}")
                      else:
                          return []
                  
                  tree = ET.parse(jacoco_path)
                  root = tree.getroot()
                  coverage_gaps = []
                  
                  for package in root.findall(".//package"):
                      package_name = package.attrib.get('name', '').replace('/', '.')
                      
                      for clazz in package.findall("class"):
                          class_name = clazz.attrib.get('name', '').replace('/', '.')
                          
                          # Skip test classes
                          if 'Test' in class_name:
                              continue
                          
                          # Check if class has a source file
                          source_file_name = clazz.attrib.get('sourcefilename')
                          if not source_file_name:
                              continue
                          
                          class_methods = []
                          total_class_methods = 0
                          covered_class_methods = 0
                          
                          for method in clazz.findall(".//method"):
                              method_name = method.attrib.get('name', '')
                              
                              # Skip constructors for now
                              if method_name == "<init>":
                                  continue
                              
                              total_class_methods += 1
                              
                              # Find instruction coverage
                              counter = method.find("counter[@type='INSTRUCTION']")
                              if counter is not None:
                                  missed = int(counter.attrib.get('missed', 0))
                                  covered = int(counter.attrib.get('covered', 0))
                                  total = missed + covered
                                  coverage = 0 if total == 0 else (covered / total) * 100
                                  
                                  # Method is considered covered if it has at least one instruction covered
                                  if covered > 0:
                                      covered_class_methods += 1
                                  
                                  # Add methods with less than min_coverage
                                  if coverage < min_coverage:
                                      class_methods.append({
                                          'method': method_name,
                                          'coverage_percentage': coverage,
                                          'missed_instructions': missed,
                                          'priority': missed  # Higher priority for more missed instructions
                                      })
                          
                          # Only include classes with methods that need testing
                          if class_methods:
                              # Calculate overall class coverage percentage
                              class_coverage = 0 if total_class_methods == 0 else (covered_class_methods / total_class_methods) * 100
                              
                              coverage_gaps.append({
                                  'package': package_name,
                                  'class': class_name,
                                  'source_file': source_file_name,
                                  'methods': class_methods,
                                  'class_coverage': class_coverage,
                                  'priority': sum(m['missed_instructions'] for m in class_methods)  # Sum of all missed instructions
                              })
                  
                  # Sort by priority (descending)
                  coverage_gaps.sort(key=lambda x: x['priority'], reverse=True)
                  return coverage_gaps
                  
              except Exception as e:
                  print(f"Error parsing JaCoCo report: {e}")
                  import traceback
                  traceback.print_exc()
                  return []
          
          def find_source_file(class_name: str, src_dirs: List[str]) -> str:
              """Find the source file for a class."""
              # Extract package and class name
              parts = class_name.split('.')
              simple_name = parts[-1]
              package_path = '/'.join(parts[:-1])
              
              # Try direct path first in each source directory
              for src_dir in src_dirs:
                  class_path = os.path.join(src_dir, package_path, f"{simple_name}.java")
                  if os.path.exists(class_path):
                      return class_path
              
              # If not found, try to find by simple name
              for src_dir in src_dirs:
                  try:
                      # Use find command to locate the file
                      result = subprocess.run(['find', src_dir, '-name', f"{simple_name}.java"], 
                                             capture_output=True, text=True)
                      if result.stdout:
                          files = result.stdout.strip().split('\n')
                          # Filter by package if possible
                          for file in files:
                              if package_path in file:
                                  return file
                          # If no exact match, return the first one
                          return files[0]
                  except Exception as e:
                      print(f"Error finding source file with find command: {e}")
              
              # If still not found, try the src/main/java and src directories
              if 'src/main/java' not in src_dirs:
                  result = find_source_file(class_name, src_dirs + ['src/main/java', 'src'])
                  if result:
                      return result
              
              print(f"Could not find source file for {class_name}")
              return None
          
          def get_class_source(file_path: str) -> str:
              """Read the source code from a file."""
              try:
                  with open(file_path, 'r') as f:
                      return f.read()
              except Exception as e:
                  print(f"Error reading source file: {e}")
                  return None
          
          def check_test_exists(class_name: str, test_dir: str) -> bool:
              """Check if a test class already exists."""
              parts = class_name.split('.')
              simple_name = parts[-1]
              package_path = '/'.join(parts[:-1])
              
              test_class_path = os.path.join(test_dir, package_path, f"{simple_name}Test.java")
              return os.path.exists(test_class_path)
          
          def write_test_class(package_name: str, class_name: str, test_code: str, test_dir: str) -> str:
              """Write the test class to a file."""
              package_path = os.path.join(test_dir, package_name.replace('.', '/'))
              os.makedirs(package_path, exist_ok=True)
              
              simple_name = class_name.split('.')[-1]
              file_path = os.path.join(package_path, f"{simple_name}Test.java")
              
              with open(file_path, 'w') as f:
                  f.write(test_code)
              
              print(f"Wrote test class to {file_path}")
              return file_path
          
          def main():
              """Main function to generate tests."""
              args = parse_args()
              
              # Find coverage gaps
              coverage_gaps = find_coverage_gaps(args.jacoco_report, args.min_coverage)
              if not coverage_gaps:
                  print("No coverage gaps found!")
                  return
              
              print(f"Found {len(coverage_gaps)} classes with low coverage")
              
              # Initialize the SambaNova API helper
              sambanova = SambaNovaCoder()
              
              # Look in multiple source directories
              src_dirs = [args.src_dir]
              if 'dropwizard-jakarta-xml-ws' in os.getcwd():
                  # We're in the main project directory
                  src_dirs = [
                      'dropwizard-jakarta-xml-ws/src/main/java',
                      'dropwizard-jakarta-xml-ws-example/src/main/java',
                      'src/main/java'
                  ]
              
              # Process classes with the most coverage gaps, up to max_classes
              processed_count = 0
              for class_data in coverage_gaps[:args.max_classes]:
                  class_name = class_data['class']
                  
                  # Skip classes that already have tests
                  simple_class_name = class_name.split('.')[-1]
                  package_name = '.'.join(class_name.split('.')[:-1])
                  if check_test_exists(class_name, args.test_dir):
                      print(f"Skipping {class_name} as it already has tests")
                      continue
                  
                  print(f"\nProcessing {class_name} with {len(class_data['methods'])} methods to test")
                  print(f"Class coverage: {class_data['class_coverage']:.1f}%")
                  
                  # Get class source
                  source_file = find_source_file(class_name, src_dirs)
                  if not source_file:
                      print(f"Could not find source file for {class_name}, skipping")
                      continue
                  
                  class_source = get_class_source(source_file)
                  if not class_source:
                      print(f"Could not read source for {class_name}, skipping")
                      continue
                  
                  # Generate tests
                  print(f"Generating tests for {class_name}...")
                  try:
                      # Print methods to test
                      print("Methods to test:")
                      for method in class_data['methods']:
                          print(f"  - {method['method']} (coverage: {method['coverage_percentage']:.1f}%)")
                      
                      test_code = sambanova.generate_complete_test_class(
                          class_source, class_name, class_data['methods']
                      )
                      
                      if not test_code:
                          print(f"No tests generated for {class_name}")
                          continue
                          
                      # Add package declaration if missing
                      if not test_code.strip().startswith("package "):
                          test_code = f"package {package_name};\n\n{test_code}"
                      
                      # Write test class
                      write_test_class(package_name, simple_class_name, test_code, args.test_dir)
                      processed_count += 1
                      
                  except Exception as e:
                      print(f"Error generating tests for {class_name}: {e}")
                      import traceback
                      traceback.print_exc()
                      continue
              
              print(f"\nGenerated tests for {processed_count} classes")
          
          if __name__ == "__main__":
              main()
          EOF

      - name: Run tests and generate coverage report
        run: mvn clean verify jacoco:report

      - name: Generate tests with JaCoCo report
        env:
          SAMBANOVA_API_KEY: ${{ secrets.SAMBANOVA_API_KEY }}
        run: |
          cd .github/scripts
          python jacoco_test_generator.py --max-classes ${{ github.event.inputs.max_classes || 5 }} --min-coverage ${{ github.event.inputs.min_coverage || 80 }}

      - name: Run tests with new test classes
        run: mvn test

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "test: Add AI-generated tests to improve coverage"
          title: "test: Add AI-generated tests to improve coverage"
          body: |
            This PR adds automatically generated tests to improve code coverage based on JaCoCo analysis.
            
            ### Generated Tests
            
            The tests were generated using Qwen2.5-Coder model with JaCoCo data to target classes with low test coverage.
            
            ### Please review
            
            - [ ] The tests are well-structured and follow project conventions
            - [ ] The tests properly test the targeted functionality
            - [ ] The tests don't have any false assumptions about the code
          branch: ai-generated-tests
          base: main